<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crucigrama Mágico - Generador Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');
        
        body { 
            font-family: 'Fredoka', sans-serif; 
            background-color: #FDFCF0; 
            overflow: hidden; 
        }

        .bg-pattern { 
            background-image: radial-gradient(#E2E8F0 1.5px, transparent 1.5px); 
            background-size: 24px 24px; 
            opacity: 0.4; 
        }

        .cruci-container {
            position: relative;
            background-size: cover;
            background-position: center;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: inset 0 0 40px rgba(0,0,0,0.05);
        }

        .cruci-cell {
            aspect-ratio: 1/1;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1.5px solid rgba(203, 213, 225, 0.8);
            background: rgba(255, 255, 255, 0.85); 
            border-radius: 4px;
            position: relative;
            backdrop-filter: blur(1px);
        }

        .cruci-cell.empty {
            background: transparent;
            border-color: transparent;
            backdrop-filter: none;
        }

        .num-label {
            position: absolute;
            top: 1px;
            left: 2px;
            font-size: 0.5rem;
            color: #4338ca;
            font-weight: bold;
        }

        .clue-badge {
            position: absolute;
            top: -5px;
            left: -5px;
            background: #4f46e5;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .scroll-hidden::-webkit-scrollbar { display: none; }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col">
    <div class="fixed inset-0 bg-pattern -z-10"></div>

    <!-- Setup View -->
    <div id="setup-view" class="flex-1 flex flex-col items-center justify-center p-6 text-center overflow-y-auto">
        <div class="mb-4 bg-yellow-400 p-4 rounded-3xl shadow-xl rotate-3 inline-block">
            <i data-lucide="puzzle" class="w-10 h-10 text-white"></i>
        </div>
        
        <h1 class="text-3xl font-black text-indigo-900 mb-2">Crucigrama con Fondo</h1>
        <p class="text-indigo-600/70 font-medium mb-6">Pistas grandes y fondos personalizados</p>

        <div class="bg-white/80 backdrop-blur-sm p-6 rounded-[2rem] shadow-2xl border-4 border-white w-full max-w-3xl space-y-4">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                <input id="pdf-name-input" type="text" placeholder="Título del PDF" class="w-full bg-indigo-50/50 border-2 border-indigo-100 rounded-xl px-4 py-3 font-bold outline-none">
                <button onclick="document.getElementById('zip-input').click()" class="w-full bg-sky-100 text-sky-700 font-bold px-4 py-3 rounded-xl border-2 border-sky-200 flex items-center justify-center gap-2">
                    <i data-lucide="folder-archive" class="w-5 h-5"></i>
                    <span id="zip-status">Imágenes (ZIP)</span>
                </button>
                <input type="file" id="zip-input" accept=".zip" class="hidden">
            </div>

            <div class="text-left">
                <label class="block text-xs font-bold text-indigo-900/60 ml-2 mb-1">Estructura JSON (Palabras e Imagen de Fondo)</label>
                <textarea id="json-input-area" rows="8" class="w-full bg-indigo-50/50 border-2 border-indigo-100 rounded-xl px-4 py-3 font-mono text-xs outline-none scroll-hidden">{
  "exercises": [
    {
      "title": "Stitch en el Parque",
      "gridSize": 10,
      "bgImageId": "img001",
      "words": [
        { "word": "correr", "imgId": "img002" },
        { "word": "pelota", "imgId": "img003" },
        { "word": "saltar", "imgId": "img004" },
        { "word": "arbol", "imgId": "img005" },
        { "word": "cometa", "imgId": "img006" },
        { "word": "jugar", "imgId": "img007" },
        { "word": "banco", "imgId": "img008" }
      ]
    },
    {
      "title": "Stitch en la Escuela",
      "gridSize": 10,
      "bgImageId": "img009",
      "words": [
        { "word": "leer", "imgId": "img010" },
        { "word": "libro", "imgId": "img011" },
        { "word": "lapiz", "imgId": "img012" },
        { "word": "escribir", "imgId": "img013" },
        { "word": "mochila", "imgId": "img014" },
        { "word": "dibujar", "imgId": "img015" },
        { "word": "pizarra", "imgId": "img016" },
        { "word": "maestro", "imgId": "img017" }
      ]
    },
    {
      "title": "Stitch en la Playa",
      "gridSize": 10,
      "bgImageId": "img018",
      "words": [
        { "word": "surfear", "imgId": "img019" },
        { "word": "tabla", "imgId": "img020" },
        { "word": "nadar", "imgId": "img021" },
        { "word": "arena", "imgId": "img022" },
        { "word": "sombrero", "imgId": "img023" },
        { "word": "beber", "imgId": "img024" },
        { "word": "coco", "imgId": "img025" }
      ]
    },
    {
      "title": "Stitch en su Habitacion",
      "gridSize": 10,
      "bgImageId": "img026",
      "words": [
        { "word": "dormir", "imgId": "img027" },
        { "word": "cama", "imgId": "img028" },
        { "word": "lampara", "imgId": "img029" },
        { "word": "leer", "imgId": "img030" },
        { "word": "libro", "imgId": "img031" },
        { "word": "despertar", "imgId": "img032" },
        { "word": "almohada", "imgId": "img033" }
      ]
    },
    {
      "title": "Stitch Cocinero",
      "gridSize": 10,
      "bgImageId": "img034",
      "words": [
        { "word": "cocinar", "imgId": "img035" },
        { "word": "comer", "imgId": "img036" },
        { "word": "pizza", "imgId": "img037" },
        { "word": "jugo", "imgId": "img038" },
        { "word": "cuchara", "imgId": "img039" },
        { "word": "plato", "imgId": "img040" },
        { "word": "beber", "imgId": "img041" },
        { "word": "mesa", "imgId": "img042" }
      ]
    }
  ]
}

ahora dame los prompts de imagen de todas las imagenes incluyendo sus bg... separadas por newline ya sabes que el tema es de STITCH 

img001: Stitch en un parque infantil colorido, estilo ilustración infantil, Stitch en una esquina saludando, árboles, flores, pelota y cometa en las esquinas, centro limpio y vacío, composición con espacio negativo en el centro, colores vibrantes, estilo caricatura, alta calidad, sin texto

img002: Stitch corriendo feliz en un parque, movimiento dinámico, expresión alegre, estilo caricatura infantil, fondo simple, colores brillantes, personaje completo visible, sin texto

img003: Stitch jugando con una pelota roja, sosteniendo la pelota con sonrisa, estilo ilustración infantil, fondo simple y limpio, colores suaves, sin texto

img004: Stitch saltando en el aire con alegría, pose dinámica, estilo caricatura infantil, fondo minimalista, colores vibrantes, sin texto

img005: Stitch abrazando un árbol amigable con cara feliz, estilo infantil, colores suaves, fondo simple, sin texto

img006: Stitch volando una cometa de colores, mirando hacia arriba feliz, estilo caricatura infantil, fondo limpio, sin texto

img007: Stitch jugando alegremente, brazos abiertos, pose divertida, estilo ilustración infantil, fondo simple, sin texto

img008: Stitch sentado en un banco de parque, relajado y feliz, estilo caricatura infantil, fondo limpio, sin texto

img009: Habitación escolar infantil con Stitch en una esquina, mochila, libros, lápices y pizarra en las esquinas, centro completamente vacío, espacio negativo en el centro, colores pastel, estilo caricatura infantil, sin texto

img010: Stitch leyendo un libro con atención, sentado, expresión curiosa, estilo ilustración infantil, fondo simple, sin texto

img011: Stitch sosteniendo un libro grande, sonriendo, estilo caricatura infantil, fondo limpio, sin texto

img012: Stitch sosteniendo un lápiz gigante, listo para escribir, estilo infantil, fondo simple, sin texto

img013: Stitch escribiendo en un cuaderno, concentrado, estilo caricatura infantil, fondo limpio, sin texto

img014: Stitch usando una mochila colorida, listo para ir a la escuela, estilo infantil, fondo simple, sin texto

img015: Stitch dibujando con crayones, feliz, estilo caricatura infantil, fondo limpio, sin texto

img016: Stitch señalando una pizarra, pose de maestro, estilo infantil, fondo simple, sin texto

img017: Stitch vestido como maestro con libro, sonriendo, estilo caricatura infantil, fondo limpio, sin texto

img018: Playa tropical con Stitch en una esquina, palmeras, tabla de surf, sombrero y coco en las esquinas, centro vacío y limpio, estilo ilustración infantil, colores brillantes, sin texto

img019: Stitch surfeando sobre una ola, feliz, estilo caricatura infantil, fondo simple, sin texto

img020: Stitch sosteniendo una tabla de surf colorida, estilo infantil, fondo limpio, sin texto

si te das cuenta primero la imagen principal backgorund que trate de tener el centro vacio y mas a los contornos luego sus imagenes como e el ejemplo recuerda que son maximo 8 imagenes aparete del background en cada ejercicio ahora quiero que hagas otro para: 
</textarea>
            </div>

            <button onclick="startApp()" class="w-full bg-indigo-600 text-white font-black text-lg py-4 rounded-2xl shadow-xl hover:bg-indigo-700 transition flex items-center justify-center gap-3">
                GENERAR AHORA
                <i data-lucide="sparkles"></i>
            </button>
        </div>
    </div>

    <!-- Main View -->
    <div id="main-view" class="hidden flex-1 flex flex-col overflow-hidden">
        <header class="p-3 flex items-center justify-between bg-white/50 border-b-2 border-indigo-50">
            <div class="flex items-center gap-2">
                <i data-lucide="puzzle" class="text-indigo-600 w-5 h-5"></i>
                <h2 id="display-pdf-title" class="font-black text-indigo-900 text-sm">Título</h2>
            </div>
            <div class="flex gap-2">
                <button onclick="location.reload()" class="p-2 rounded-xl bg-white border-2 border-indigo-50 text-indigo-400 hover:text-indigo-600 transition"><i data-lucide="refresh-cw" class="w-4 h-4"></i></button>
                <button onclick="generatePDF()" class="bg-pink-500 text-white font-black px-5 py-2 rounded-xl shadow-lg flex items-center gap-2 text-sm hover:bg-pink-600 transition">
                    <i data-lucide="printer" class="w-4 h-4"></i> IMPRIMIR PDF
                </button>
            </div>
        </header>

        <main id="preview-list" class="flex-1 overflow-y-auto p-8 flex flex-col items-center gap-12 scroll-hidden"></main>
    </div>

    <script>
     

        let appData = null;
        let imageMap = {};
        let pdfTitle = "Crucigrama Mágico";

     

        document.getElementById('zip-input').onchange = (e) => {
            document.getElementById('zip-status').innerText = e.target.files[0]?.name || 'Imágenes (ZIP)';
        };

        async function startApp() {
            const zipFile = document.getElementById('zip-input').files[0];
            const jsonText = document.getElementById('json-input-area').value;
            const titleInput = document.getElementById('pdf-name-input').value;
            
            if(titleInput) pdfTitle = titleInput;

            try {
                appData = JSON.parse(jsonText);
                if (zipFile) {
                    const zip = await JSZip.loadAsync(zipFile);
                    for (const [path, entry] of Object.entries(zip.files)) {
                        if (!entry.dir) {
                            const ext = path.split('.').pop().toLowerCase();
                            const data = await entry.async("base64");
                            // Corregido: eliminación de escapes innecesarios que causaban SyntaxError
                            const cleanName = path.split('/').pop().replace(/\.[^/.]+$/, "");
                            const mimeType = (ext === 'png') ? 'image/png' : 'image/jpeg';
                            imageMap[cleanName] = `data:${mimeType};base64,${data}`;
                        }
                    }
                }

                document.getElementById('setup-view').classList.add('hidden');
                document.getElementById('main-view').classList.remove('hidden');
                document.getElementById('display-pdf-title').innerText = pdfTitle;
                processAndRender();
            } catch (e) { 
                console.error(e);
                alert("Error al procesar: " + e.message); 
            }
        }

        function generateLayout(words, size) {
            const grid = Array(size).fill().map(() => Array(size).fill(null));
            const placedWords = [];
            const sortedWords = [...words].sort((a, b) => b.word.length - a.word.length);

            function canPlace(word, row, col, dir) {
                if (dir === 'H' && col + word.length > size) return false;
                if (dir === 'V' && row + word.length > size) return false;
                let connections = 0;
                for (let i = 0; i < word.length; i++) {
                    const r = dir === 'H' ? row : row + i;
                    const c = dir === 'H' ? col + i : col;
                    const current = grid[r][c];
                    if (current && current !== word[i]) return false;
                    if (current === word[i]) connections++;
                }
                return placedWords.length === 0 || connections > 0;
            }

            function place(wordObj, row, col, dir) {
                for (let i = 0; i < wordObj.word.length; i++) {
                    const r = dir === 'H' ? row : row + i;
                    const c = dir === 'H' ? col + i : col;
                    grid[r][c] = wordObj.word[i];
                }
                placedWords.push({ ...wordObj, row, col, orientation: dir, id: placedWords.length + 1 });
            }

            sortedWords.forEach(w => {
                const attempts = [];
                for(let r=0; r<size; r++) for(let c=0; c<size; c++) {
                    attempts.push({r, c, d: 'H'}, {r, c, d: 'V'});
                }
                attempts.sort(() => Math.random() - 0.5);
                for(const att of attempts) {
                    if(canPlace(w.word, att.r, att.c, att.d)) {
                        place(w, att.r, att.c, att.d);
                        break;
                    }
                }
            });
            return { grid, placedWords };
        }

        function processAndRender() {
            const container = document.getElementById('preview-list');
            container.innerHTML = '';

            appData.exercises.forEach((ex, idx) => {
                const { grid, placedWords } = generateLayout(ex.words, ex.gridSize);
                ex.calculatedWords = placedWords;
                ex.calculatedGrid = grid;

                const sheet = document.createElement('div');
                sheet.className = "bg-white w-[210mm] min-h-[297mm] p-12 shadow-2xl flex flex-col mb-8 relative shrink-0";
                
                const bgImg = imageMap[ex.bgImageId] || '';
                
                let gridHtml = `
                <div class="cruci-container mx-auto p-4 shadow-inner bg-slate-100" style="width: 500px; height: 500px; background-image: url('${bgImg}')">
                    <div class="grid gap-1 h-full w-full" style="grid-template-columns: repeat(${ex.gridSize}, 1fr);">`;
                
                for(let r=0; r < ex.gridSize; r++) {
                    for(let c=0; c < ex.gridSize; c++) {
                        const char = grid[r][c];
                        const wordStart = placedWords.find(pw => pw.row === r && pw.col === c);
                        if(char) {
                            gridHtml += `
                                <div class="cruci-cell">
                                    ${wordStart ? `<span class="num-label">${wordStart.id}</span>` : ''}
                                    <span class="opacity-10 text-[10px] font-bold select-none">${char.toUpperCase()}</span>
                                </div>`;
                        } else {
                            gridHtml += `<div class="cruci-cell empty"></div>`;
                        }
                    }
                }
                gridHtml += '</div></div>';

                let cluesHtml = `<div class="grid grid-cols-4 gap-6">`;
                placedWords.forEach(w => {
                    cluesHtml += `
                        <div class="clue-card bg-white p-2 rounded-2xl border-2 border-indigo-50 shadow-sm">
                            <div class="clue-badge">${w.id}</div>
                            <div class="aspect-square w-full flex items-center justify-center bg-slate-50 rounded-xl overflow-hidden p-1">
                                ${imageMap[w.imgId] ? `<img src="${imageMap[w.imgId]}" class="max-w-full max-h-full object-contain">` : `<span class="text-xs text-slate-300 font-bold">${w.imgId}</span>`}
                            </div>
                        </div>`;
                });
                cluesHtml += `</div>`;

                sheet.innerHTML = `
                    <div class="border-b-4 border-indigo-600 pb-4 mb-8 flex justify-between items-end">
                        <h2 class="text-3xl font-black text-indigo-900 tracking-tight">${ex.title}</h2>
                        <div class="bg-indigo-600 text-white px-4 py-1 rounded-full text-sm font-bold">RETO ${idx+1}</div>
                    </div>
                    <div class="flex-1 flex flex-col justify-center">
                        ${gridHtml}
                    </div>
                    <div class="mt-8 pt-8 border-t-2 border-dashed border-indigo-100">
                        <h3 class="text-center font-black text-indigo-200 uppercase tracking-[0.4em] mb-6 text-sm">Pistas Visuales</h3>
                        ${cluesHtml}
                    </div>
                `;
                container.appendChild(sheet);
            });
            lucide.createIcons();
        }

        async function generatePDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');

            for(let i=0; i<appData.exercises.length; i++) {
                const ex = appData.exercises[i];
                if (i > 0) doc.addPage();
                
                doc.setFillColor(253, 252, 240);
                doc.rect(0, 0, 210, 297, 'F');

                doc.setFont("helvetica", "bold");
                doc.setFontSize(22);
                doc.setTextColor(30, 27, 75);
                doc.text(ex.title.toUpperCase(), 20, 25);

                const gridAreaSize = 130;
                const startX = (210 - gridAreaSize) / 2;
                const startY = 40;

                if(imageMap[ex.bgImageId]) {
                    try {
                        const format = imageMap[ex.bgImageId].includes('png') ? 'PNG' : 'JPEG';
                        doc.saveGraphicsState();
                        doc.setGState(new doc.GState({opacity: 0.3}));
                        doc.addImage(imageMap[ex.bgImageId], format, startX, startY, gridAreaSize, gridAreaSize);
                        doc.restoreGraphicsState();
                    } catch(e) { console.error("Error bg image:", e); }
                } else {
                    doc.setFillColor(240, 244, 248);
                    doc.roundedRect(startX, startY, gridAreaSize, gridAreaSize, 2, 2, 'F');
                }

                const cellSize = gridAreaSize / ex.gridSize;
                for(let r=0; r < ex.gridSize; r++) {
                    for(let c=0; c < ex.gridSize; c++) {
                        if(ex.calculatedGrid[r][c]) {
                            const x = startX + (c * cellSize);
                            const y = startY + (r * cellSize);
                            
                            doc.setDrawColor(180, 180, 180);
                            doc.setLineWidth(0.2);
                            doc.setFillColor(255, 255, 255); 
                            
                            doc.roundedRect(x + 0.2, y + 0.2, cellSize - 0.4, cellSize - 0.4, 0.8, 0.8, 'FD');
                            
                            const wordStart = ex.calculatedWords.find(pw => pw.row === r && pw.col === c);
                            if(wordStart) {
                                doc.setFontSize(7);
                                doc.setTextColor(79, 70, 229);
                                doc.text(wordStart.id.toString(), x + 1, y + 2.5);
                            }
                        }
                    }
                }

                const cluesStartY = startY + gridAreaSize + 25;
                const clueBoxSize = 32;
                const gap = 8;
                const cols = 4;

                ex.calculatedWords.forEach((w, idx) => {
                    const col = idx % cols;
                    const row = Math.floor(idx / cols);
                    const x = 30 + (col * (clueBoxSize + gap));
                    const y = cluesStartY + (row * (clueBoxSize + gap));

                    doc.setDrawColor(220, 220, 220);
                    doc.setFillColor(255, 255, 255);
                    doc.roundedRect(x, y, clueBoxSize, clueBoxSize, 3, 3, 'FD');
                    
                    if(imageMap[w.imgId]) {
                        try {
                            const format = imageMap[w.imgId].includes('png') ? 'PNG' : 'JPEG';
                            doc.addImage(imageMap[w.imgId], format, x + 2, y + 2, clueBoxSize - 4, clueBoxSize - 4);
                        } catch(e) {}
                    }
                    
                    doc.setFillColor(79, 70, 229);
                    doc.roundedRect(x - 2, y - 2, 7, 7, 1.5, 1.5, 'F');
                    doc.setTextColor(255, 255, 255);
                    doc.setFontSize(9);
                    doc.text(w.id.toString(), x + 1.5, y + 3, { align: 'center' });
                });

                doc.setFontSize(8);
                doc.setTextColor(180);
                doc.text(`${pdfTitle.toUpperCase()} - RETO ${i+1}`, 105, 288, { align: 'center' });
            }

            const pdfBlob = doc.output('blob');
            const url = URL.createObjectURL(pdfBlob);
            window.open(url, '_blank');
        }
    </script>
</body>
</html>